package require tcltest
package require llvmtcl
namespace import llvmtcl::*

tcltest::test api-1 {build an example with llvm C api wrapper and execute it} -body {
    # Initialize the JIT
    LLVMLinkInJIT
    LLVMInitializeNativeTarget
    # Create a module and builder
    set m [LLVMModuleCreateWithName "testmodule"]
    set bld [LLVMCreateBuilder]
    # Create a plus10 function, taking one argument and adding 6 and 4 to it
    set ft [LLVMFunctionType [LLVMInt32Type] [list [LLVMInt32Type]] 0]
    set plus10 [LLVMAddFunction $m "plus10" $ft]
    # Create constants
    set c6 [LLVMConstInt [LLVMInt32Type] 6 0]
    set c4 [LLVMConstInt [LLVMInt32Type] 4 0]
    # Create the basic blocks
    set entry [LLVMAppendBasicBlock $plus10 entry]
    # Put arguments on the stack to avoid having to write select and/or phi nodes
    LLVMPositionBuilderAtEnd $bld $entry
    set arg0_1 [LLVMGetParam $plus10 0]
    set arg0_2 [LLVMBuildAlloca $bld [LLVMInt32Type] arg0]
    set arg0_3 [LLVMBuildStore $bld $arg0_1 $arg0_2]
    # Do add 10 in two steps to see the optimizer @ work
    # Add 6
    set arg0_4 [LLVMBuildLoad $bld $arg0_2 "arg0"]
    set add6 [LLVMBuildAdd $bld $arg0_4 $c6 "add6"]
    # Add 4
    set add4 [LLVMBuildAdd $bld $add6 $c4 "add4"]
    # Set return
    LLVMBuildRet $bld $add4
    # Show input
    # Verify the module
    lassign [LLVMVerifyModule $m LLVMReturnStatusAction] rt msg
    if {$rt} {
	error $msg
    }
    # Execute
    lassign [LLVMCreateJITCompilerForModule $m 0] rt EE msg
    set i [LLVMCreateGenericValueOfInt [LLVMInt32Type] 4 0]
    set res [LLVMRunFunction $EE $plus10 $i]
    set result {}
    lappend result [LLVMGenericValueToInt $res 0]
    # Optimize
    set td [LLVMCreateTargetData ""]
    LLVMSetDataLayout $m [LLVMCopyStringRepOfTargetData $td]
    LLVMOptimizeFunction $m $plus10 3 $td
    LLVMOptimizeModule $m 3 0 1 1 1 0 $td
    # Execute optimized code
    set res [LLVMRunFunction $EE $plus10 $i]
    lappend result [LLVMGenericValueToInt $res 0]
} -cleanup {
    LLVMDisposeBuilder $bld
    LLVMDisposeModule $m
} -result {14 14}

tcltest::test api-2 {build an example with llvm C api wrapper and execute it} -body {
    # Initialize the JIT
    LLVMLinkInJIT
    LLVMInitializeNativeTarget
    # Create a module and builder
    set m [LLVMModuleCreateWithName "testmodule"]
    set bld [LLVMCreateBuilder]
    # Create a function with an int32 argument returning an int32
    set ft [LLVMFunctionType [LLVMInt32Type] [list [LLVMInt32Type]] 0]
    set fac [LLVMAddFunction $m "fac" $ft]
    # Create constants
    set two [LLVMConstInt [LLVMInt32Type] 2  0]
    set one [LLVMConstInt [LLVMInt32Type] 1  0]
    # Create the basic blocks
    set entry [LLVMAppendBasicBlock $fac entry]
    set exit_lt_2 [LLVMAppendBasicBlock $fac exit_lt_2]
    set recurse [LLVMAppendBasicBlock $fac recurse]
    # Put arguments on the stack to avoid having to write select and/or phi nodes
    LLVMPositionBuilderAtEnd $bld $entry
    set arg0_1 [LLVMGetParam $fac 0]
    set arg0_2 [LLVMBuildAlloca $bld [LLVMInt32Type] arg0]
    set arg0_3 [LLVMBuildStore $bld $arg0_1 $arg0_2]
    # Compare input < 2
    set arg0_4 [LLVMBuildLoad $bld $arg0_2 "n"]
    set cc [LLVMBuildICmp $bld LLVMIntSLT $arg0_4 $two "cc"]
    # Branch
    LLVMBuildCondBr $bld $cc $exit_lt_2 $recurse
    # If n < 2, return 1
    LLVMPositionBuilderAtEnd $bld $exit_lt_2
    LLVMBuildRet $bld $one
    # If >= 2, return n*fac(n-1)
    LLVMPositionBuilderAtEnd $bld $recurse
    set arg0_5 [LLVMBuildLoad $bld $arg0_2 "n"]
    set arg0_minus_1 [LLVMBuildSub $bld $arg0_5 $one "arg0_minus_1"]
    set fc [LLVMBuildCall $bld $fac [list $arg0_minus_1] "rec"]
    set rt [LLVMBuildMul $bld $arg0_5 $fc "rt"]
    LLVMBuildRet $bld $rt
    # Done
    # Create function returning fac(10)
    set ft [LLVMFunctionType [LLVMInt32Type] [list] 0]
    set fac10 [LLVMAddFunction $m "fac10" $ft]
    set ten [LLVMConstInt [LLVMInt32Type] 10 0]
    set main [LLVMAppendBasicBlock $fac10 main]
    LLVMPositionBuilderAtEnd $bld $main
    set rt [LLVMBuildCall $bld $fac [list $ten] "rec"]
    LLVMBuildRet $bld $rt
    # Verify the module
    lassign [LLVMVerifyModule $m LLVMReturnStatusAction] rt msg
    if {$rt} {
	error $msg
    }
    # Run the fac and fac10 functions
    lassign [LLVMCreateJITCompilerForModule $m 0] rt EE msg
    set i [LLVMCreateGenericValueOfInt [LLVMInt32Type] 5 0]
    set res [LLVMRunFunction $EE $fac $i]
    set result {}
    lappend result [LLVMGenericValueToInt $res 0]
    set res [LLVMRunFunction $EE $fac10 {}]
    lappend result [LLVMGenericValueToInt $res 0]
    # Optimize functions and module
    set td [LLVMCreateTargetData ""]
    LLVMSetDataLayout $m [LLVMCopyStringRepOfTargetData $td]
    for {set t 0} {$t < 10} {incr t} {
	LLVMOptimizeFunction $m $fac 3 $td
	LLVMOptimizeFunction $m $fac10 3 $td
	LLVMOptimizeModule $m 3 0 1 1 1 0  $td
    }
    set res [LLVMRunFunction $EE $fac $i]
    lappend result [LLVMGenericValueToInt $res 0]
    set res [LLVMRunFunction $EE $fac10 {}]
    lappend result [LLVMGenericValueToInt $res 0]
} -cleanup {
    LLVMDisposeBuilder $bld
    LLVMDisposeModule $m
} -result {120 3628800 120 3628800}

# cleanup
::tcltest::cleanupTests
return
